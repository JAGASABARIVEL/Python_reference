"""
The following functions are used for PPS V3 API.
"""

#from scripts.cornercase_scripts.cornercase_set1_scripts.L1commonFunctions import *
from L1commonFunctions import *
import re


def get_booking_header(plannerId):
    try:
        planner = "{\"hhId\":\"%s\"}"%plannerId
        header = {
                "x-cisco-vcs-identity":planner,
                "Content-Type":"application/json"
                }
        return header
    except Exception as e:
        print "Error in get booking headers :\n",str(e)
        return None


def get_header(plannerId):
    planner = "{\"hhId\":\"%s\"}" % plannerId
    header = {
                 "x-cisco-vcs-identity":planner
             }
    return header


def create_series_booking(cfg, plannerId, payload, timeout=2, pps_host=None, update=False):
    """
    Create a Event booking and return whole response
    :param cfg: config parameter
    :param plannerId: planner id
    :param payload: payload for booking
    :param timeout: timeout value
    :param pps_host: pps host <optional>
    :return:
    """

    try:
        protocol = cfg['protocol']
        pps_port = cfg['pps']['port']

        if pps_host is None:
            pps_host = cfg['pps']['host']

        headers = get_header(plannerId)
        if headers is None:
            print "Unable to get the Booking headers"
            return False, None

        print "Headers :",headers

        if update:
            url = protocol + "://" + pps_host + ":" + str(pps_port) + "/pps/v3/core/recurrences/updateRecurrence"
            print "PPS V3 Event Booking via url : %s" % url
        else:
            url = protocol + "://" + pps_host + ":" + str(pps_port) + "/pps/v3/core/recurrences/createGroupRecurrence"
            print "PPS V3 Event Booking via url : %s" % url

        r = sendURL("post", url, server_timeout=timeout, header=headers, payload_content=payload)

        if r is not None:
            if r.status_code != 200:
                print "PPS V3 Event Booking / Update Failed"
                print r.status_code
                print r.headers
                return False, r
            else:
                # print "PPS V3 - Event Booking successful"
                return True, r
        else:
            return False, None

    except Exception as e:
        print "Error in PPS V3 Event booking :\n", str(e)
        return False, None


def create_event_booking(cfg, plannerId, payload, timeout=2, pps_host=None, timeBooking = False):
    """
    Create a Event booking and return whole response
    :param cfg: config parameter
    :param plannerId: planner id
    :param payload: payload for booking
    :param timeout: timeout value
    :param pps_host: pps host <optional>
    :return:
    """

    try:
        protocol = cfg['protocol']
        pps_port = cfg['pps']['port']

        if pps_host is None:
            pps_host = cfg['pps']['host']

        headers = get_header(plannerId)
        if headers is None:
            print "Unable to get the Booking headers"
            return False, None

        print "Headers :",headers

        if timeBooking:
            url = protocol + "://" + pps_host + ":" + str(pps_port) + "/pps/v3/core/bookings/createTimeBooking"
            print "PPS V3 Event Booking via url : %s" % url

        else:
            url = protocol + "://" + pps_host + ":" + str(pps_port) + "/pps/v3/core/bookings/createEventBooking"
            print "PPS V3 Event Booking via url : %s" % url

        r = sendURL("post", url, server_timeout=timeout, header=headers, payload_content=payload)

        if r is not None:
            if r.status_code != 200:
                print "PPS V3 Event Booking Failed"
                print r.status_code
                print r.headers
                return False, r
            else:
                # print "PPS V3 - Event Booking successful"
                return True, r
        else:
            return False, None

    except Exception as e:
        print "Error in PPS V3 Event booking :\n", str(e)
        return False, None


def update_booking_or_recording(cfg, plannerId, itemId, pps_host=None, endGuardTime=0, startGuardTime=0, keep=None,
                                autoDeletePeriod=None, lock=None, recordingUpdate=False, timeout=2):
    """
    Update an existing booking or recording either one or more of the parameters
    :param cfg:
    :param plannerId: <Mandate>
    :param itemId:
    :param pps_host:
    :param endGuardTime:
    :param startGuardTime:
    :param keep:
    :param autoDeletePeriod:
    :param lock:
    :param timeout:
    :return:
    """
    try:
        protocol = cfg['protocol']
        pps_port = cfg['pps']['port']
        payload = {}

        if pps_host is None:
            pps_host = cfg['pps']['host']

        headers = get_header(plannerId)
        if headers is None:
            print "Unable to get the Booking headers"
            return False, None

        print "Headers :", headers

        payload["itemId"] = itemId

        if keep:
            payload["keep"] = keep

        if autoDeletePeriod:
            payload["autoDeletePeriod"] = autoDeletePeriod

        if lock:
            payload["lock"] = lock

        if recordingUpdate:
            url = protocol + "://" + pps_host + ":" + str(pps_port) + "/pps/v3/core/recordings/updateRecording"
            print "PPS V3 Event Recording Update via url : %s" % url
            if payload.has_key("startGuardTime") or payload.has_key("endGuardTime"):
                print "INPUT ERROR: Can not update Guard time for recorded Events."
                return False, "Can not update Guard time for recorded Events"
        else:
            url = protocol + "://" + pps_host + ":" + str(pps_port) + "/pps/v3/core/bookings/updateBooking"
            print "PPS V3 Event Booking Update via url : %s" % url

        r = sendURL("post", url, server_timeout=timeout, header=headers, payload_content=payload)

        if r is not None:
            if r.status_code != 200:
                print "PPS V3 Event Recording update Failed"
                print r.status_code
                print r.headers
                return False, r
            else:
                print "Event Recording update is successful"
                return True, r
        else:
            return False, None

    except Exception as e:
        print "Error in PPS V3 Event Recording Updation :\n", str(e)
        return False, None


def create_booking(cfg, plannerId, channelId, startTime=0, duration=0, contentRef=None, timeout=2, pps_host=None,
                   groupId=None, endGuardTime=0, startGuardTime=0, keep=None, autoDeletePeriod=None, lock=None,
                   groupType=None, channelPreference=None, canBookReruns=None, recordingsToKeep=0, timeBooking=False):
    """
    Create a event / series / time-based Booking and verify the response and return the itemId
    ChannelPreference can either be [[CHANNEL-PREFERRED, CHANNEL-ONLY]
    :param cfg:
    :param plannerId:
    :param payload:
    :param timeout:
    :param pps_host:
    :return:
    """
    local_args = locals()
    payload = {}
    for i, j in zip(local_args.keys(), local_args.values()):
        if i in ["startTime", "duration"]:   # CONVERSION OF MINUTES TO ISO FORMAT
            if i.isdigit():
                i = epoch2iso(i)

        if i in ['startGuardTime', 'endGuardTime']:  # CONVERSION OF MINS TO 'PTHMS' FORMAT
            i = sec2interval(i)

        if local_args[i]:
            payload[i] = j

    if local_args["timeBooking"] or local_args['groupType']:    # FOR TIME BOOKING, RECURRENCE DOESNT NEED CONTENT REF
        if payload.has_key("contentRef"):
            del payload["contentRef"]

    if local_args["groupType"]:
        if "duration" in payload.keys():
            del payload['duration']         # RECURRENCE BOOKING DOES NOT NEED DURATION, START TIME
        if "startTime" in payload.keys():
            del payload['startTime']

        payload = str(payload)
        res, response = create_series_booking(cfg, plannerId, payload, pps_host)
    elif local_args["timeBooking"]:
        payload = str(payload)
        res, response = create_event_booking(cfg, plannerId, payload, timeout, pps_host, timeBooking=True)
    else:
        payload = str(payload)
        res, response = create_event_booking(cfg, plannerId, payload, pps_host)

    if res:
        resp = json.loads(response.content)
        if resp['status'] == "CREATED" and resp['itemId']:
            print "PPS V3 Event Booking successful "
            return True, resp['itemId']
        elif resp['status'] == "EXISTING":
            print "Conflict - Event is already exists"
            return False, response
        else:
            print "PPS Booking response Status :", resp['status']
            return False, None
    else:
        return False, response


def update_series_booking(cfg, plannerId, channelId, timeout=2, pps_host=None, groupId=None, endGuardTime=0,
                          startGuardTime=0, keep=None, autoDeletePeriod=None, lock=None, groupType=None,
                          channelPreference=None, canBookReruns=None, recordingsToKeep=0):
    """
    Create a event Booking and verify the response and return the itemid
    ChannelPreference can either be [[CHANNEL-PREFERRED, CHANNEL-ONLY]
    :param cfg:
    :param plannerId:
    :param payload:
    :param timeout:
    :param pps_host:
    :return:
    """
    local_args = locals()
    payload = {}
    for i, j in zip(local_args.keys(), local_args.values()):

        if i in ['startGuardTime', 'endGuardTime']:
            i = sec2interval(i)

        if local_args[i]:
            payload[i] = j

    payload = str(payload)
    res, response = create_series_booking(cfg, plannerId, payload, update=True)

    if res:
        resp = json.loads(response.content)
        if resp['status'] == "UPDATED" and resp['itemId']:
            print "PPS V3 Event Booking UPDATE successful"
            return True, resp['itemId']
        elif resp['status'] == "EXISTING":
            print "Conflict - Event Update requires some change"
            return False, response
        else:
            print "PPS Booking response Status :", resp['status']
            return False, None
    else:
        return False, response


def get_booking(cfg, plannerId, itemid, timeout=2, pps_host=None, recurrence=False):
    """
    Get the All the bookings of a Planner Id for Indie events, & recurrence bookings.
    :param cfg:
    :param plannerId:
    :param state:
    :param timeout:
    :param pps_host:
    :return:
    """

    try:
        protocol = cfg['protocol']
        pps_port = cfg['pps']['port']

        if pps_host is None:
            pps_host = cfg['pps']['host']

        header = get_header(plannerId)
        if header is None:
            print "Unable to get the headers"
            return False, None

        if recurrence:
            url = protocol + "://" + pps_host + ":" + str(pps_port) + "/pps/v3/core/recurrences/getRecurrence?itemId" \
                                                                      "=%s"%itemid
            print "Get recurrence via URL : ", url

        else:
            url = protocol + "://" + pps_host + ":" + str(pps_port) + "/pps/v3/core/bookings/getBooking?itemId=%s"%itemid
            print "Get Booking via URL : ", url

        r = sendURL("get", url, server_timeout=timeout, header=header)

        if r is not None:
            if r.status_code != 200:
                print "PPS V3 Unable to get booking"
                print r.status_code
                print r.headers
                return False, r
            else:
                print "PPS V3 got the booking"
                return True, r
        else:
            return False, None

    except Exception as e:
        print "Error in PPS V3 get Booking :\n", str(e)
        return False, None


def get_bookings(cfg, plannerId, timeout=2, pps_host=None, sortOrder="CREATE-DATE", recordingState="ALL", limit=999,
                 recurrence=False):
    """
    Get the All the bookings of a Planner Id. By default it is displayed by Create-Date sorted manner.
    Additional options for sorting are [CREATE-DATE, START-TIME, CREATE-DATE-REVERSE, START-TIME-REVERSE]
    Can be sorted based on the recordingState as well. Options are [ALL, RECORDING, NOT-STARTED]
    :param cfg:
    :param plannerId:
    :param state:
    :param timeout:
    :param pps_host:
    :return:
    """

    try:
        protocol = cfg['protocol']
        pps_port = cfg['pps']['port']

        if pps_host is None:
            pps_host = cfg['pps']['host']

        header = get_header(plannerId)
        if header is None:
            print "Unable to get the headers"
            return False, None
        if recurrence:
            url = protocol + "://" + pps_host + ":" + str(pps_port) + "/pps/v3/core/recurrences/getRecurrences"

        else:
            url = protocol + "://" + pps_host + ":" + str(pps_port) + "/pps/v3/core/bookings/getBookings?sort=%s&" \
                                                                      "recordingState=%s&limit=%d" % (sortOrder,
                                                                                                      recordingState,
                                                                                                      limit)
        print "Get request sent via URL: ", url
        r = sendURL("get", url, server_timeout=timeout, header=header)
        print "Get Bookings via URL : ", url

        if r is not None:
            if r.status_code != 200:
                print "PPS V3 Unable to get bookings"
                print r.status_code
                print r.headers
                return False, r
            else:
                print "PPS V3 got the bookings"
                return True, r
        else:
            return False, None

    except Exception as e:
        print "Error in PPS V3 get Bookings :\n", str(e)
        return False, None


def find_bookings_by_start_time(cfg, channel, starttime, plannerid, timeout=2, pps_host=None):
    """
    Get a booking based on the start time
    :param cfg: config parameter
    :param channel: channel number as string
    :param starttime: starttime of booking, it should be in ISO format
    :param plannerid: planner id
    :param timeout: timeout value
    :param pps_host: pps host <optional>
    :return: (True, Booking response) if success else (False, None)
    """
    try:
        protocol = cfg['protocol']
        pps_port = cfg['pps']['port']

        if pps_host is None:
            pps_host = cfg['pps']['host']

        header = get_header(plannerid)
        if header is None:
            print "Unable to get the headers"
            return False, None

        url = protocol + "://" + pps_host + ":" + str(pps_port) + "/pps/v3/core/bookings/findBookingsByStartTime?" \
                                                                  "channel=%s&eventStartTime=%s" %(channel, starttime)

        r = sendURL("get", url, server_timeout=timeout, header=header)
        print "Find Bookings by start time via URL : ", url

        if r is not None:
            if r.status_code != 200:
                print "PPS V3 Unable to find bookings by start time"
                print r.status_code
                print r.headers
                return False, r
            else:
                print "PPS V3 - found the bookings by start time"
                return True, r
        else:
            return False, None

    except Exception as e:
        print "Error in PPS V3 find Bookings by start time :\n", str(e)
        return False, None


def find_bookings_by_contentref(cfg, contentref, plannerId, timeout=2, pps_host=None):
    """
    Find the bookings based on the content ref
    :param cfg: config parameter
    :param contentref: contentRef of the booked content
    :param plannerId: planner id
    :param timeout: timeout value
    :param pps_host: pps host <optional>
    :return: (True, Booking response) if success else (False, None)
    """
    try:
        protocol = cfg['protocol']
        pps_port = cfg['pps']['port']

        if pps_host is None:
            pps_host = cfg['pps']['host']

        header = get_header(plannerId)
        if header is None:
            print "Unable to get the headers"
            return False, None

        url = protocol + "://" + pps_host + ":" + str(pps_port) + "/pps/v3/core/bookings/findBookingsByStartTime?" \
                                                                  "contentRef=%s" % (contentref)

        r = sendURL("get", url, server_timeout=timeout, header=header)
        print "Find Bookings by contentref via URL : ", url

        if r is not None:
            if r.status_code != 200:
                print "PPS V3 Unable to find bookings by contentref"
                print r.status_code
                print r.headers
                return False, r
            else:
                print "PPS V3 - found the bookings by contentRef"
                return True, r
        else:
            return False, None

    except Exception as e:
        print "Error in PPS V3 find Bookings by contentref :\n", str(e)
        return False, None


def find_recurrences_by_groupId_Type(cfg, channel, starttime, plannerid, groupId, groupType, timeout=2, pps_host=None):
    """
    Get a recurrence booking based on the groupId & groupType
    :param cfg: config parameter
    :param channel: channel number as string
    :param groupId: string
    :param groupType: string
    :param plannerid: planner id
    :param timeout: timeout value
    :param pps_host: pps host <optional>
    :return: (True, Booking response) if success else (False, None)
    """
    try:
        protocol = cfg['protocol']
        pps_port = cfg['pps']['port']

        if pps_host is None:
            pps_host = cfg['pps']['host']

        header = get_header(plannerid)
        if header is None:
            print "Unable to get the headers"
            return False, None

        url = protocol + "://" + pps_host + ":" + str(pps_port) + "/pps/v3/core/recurrences/findGroupRecurrence?" \
                                                                  "groupId=%s&groupType=%s" %(groupId, groupType)

        r = sendURL("get", url, server_timeout=timeout, header=header)
        print "Find Recurrences by groupId & groupType via URL : ", url

        if r is not None:
            if r.status_code != 200:
                print "PPS V3 Unable to find bookings by groupId & groupType"
                print r.status_code
                print r.headers
                return False, r
            else:
                print "PPS V3 - found the bookings by groupId & groupType"
                return True, r
        else:
            return False, None

    except Exception as e:
        print "Error in PPS V3 find Bookings by groupId & groupType:\n", str(e)
        return False, None


def delete_booking(cfg, plannerId, itemid, timeout=2, pps_host=None, recurrence=False):
    """
    Delete a Event booking or Series booking based on the payload passed
    :param cfg:
    :param plannerId:
    :param timeout:
    :param printflg:
    :param pps_host:
    :return:
    """

    try:
        protocol = cfg['protocol']
        pps_port = cfg['pps']['port']

        if pps_host is None:
            pps_host = cfg['pps']['host']

        headers = get_header(plannerId)
        if headers is None:
            print "Unable to get the Booking headers"
            return False, None

        payload = """{
                      "itemId" : %s
                      }""" % itemid

        print "Headers :",headers
        if recurrence:
            url = protocol + "://" + pps_host + ":" + str(pps_port) + "/pps/v3/core/recurrences/deleteRecurrence"
        else:
            url = protocol + "://" + pps_host + ":" + str(pps_port) + "/pps/v3/core/bookings/deleteBooking"

        r = sendURL("post", url, server_timeout=timeout, header=headers, payload_content=payload)
        print "Delete booking via URL :", url

        if r is not None:
            if r.status_code != 204:
                print "PPS V3 Delete_Booking Failed"
                print r.status_code
                print r.headers
                return False, r
            else:
                print "PPS V3 - Delete_Booking successful"
                return True, r
        else:
            return False, None

    except Exception as e:
        print "Error in PPS V3 Delete_booking :\n", str(e)
        return False, None


def get_failures(cfg, plannerId, timeout=2, pps_host=None, limit=999):
    """
    Get the failures of Planner
    :param cfg:
    :param plannerId:
    :param timeout:
    :param pps_host:
    :return:
    """
    protocol = cfg['protocol']
    pps_port = cfg['pps']['port']

    if pps_host is None:
        pps_host = cfg['pps']['host']

    header = get_header(plannerId)
    if header is None:
        print "Unable to get the headers"
        return False, None

    url = protocol + "://" + pps_host + ":" + str(pps_port) + "/pps/v3/core/failures/getFailures?limit=%d" % limit
    print "Get failures with url :",url
    r = sendURL("get", url, server_timeout=timeout, header=header)

    if r.status_code == 200:
        return r
    else:
        return False


def get_failure(cfg, plannerId, itemId, timeout=2, pps_host=None):
    """
    Get the particular failure based on itemId of Planner
    :param cfg:
    :param plannerId:
    :param timeout:
    :param pps_host:
    :return:
    """
    protocol = cfg['protocol']
    pps_port = cfg['pps']['port']

    if pps_host is None:
        pps_host = cfg['pps']['host']

    header = get_header(plannerId)
    if header is None:
        print "Unable to get the headers"
        return False, None

    url = protocol + "://" + pps_host + ":" + str(pps_port) + "/pps/v3/core/failures/getFailure?itemId=%s" % itemId
    print "Get failures with url :",url
    r = sendURL("get", url, server_timeout=timeout, header=header)

    if r.status_code == 200:
        return r
    else:
        return False


def delete_failure(cfg, plannerId, itemId, timeout=2, pps_host=None):
    """
    Get the particular failure based on itemId of Planner
    :param cfg:
    :param plannerId:
    :param timeout:
    :param pps_host:
    :return:
    """
    protocol = cfg['protocol']
    pps_port = cfg['pps']['port']

    if pps_host is None:
        pps_host = cfg['pps']['host']

    header = get_header(plannerId)
    if header is None:
        print "Unable to get the headers"
        return False, None

    url = protocol + "://" + pps_host + ":" + str(pps_port) + "/pps/v3/core/failures/deleteFailure?itemId=%s" % itemId
    print "Delete failures with url :", url
    r = sendURL("delete", url, server_timeout=timeout, header=header)

    if r.status_code == 200:
        return True, None
    else:
        return False, r


def delete_allbookingsinGroup(cfg, plannerId, itemId, groupId, groupType, timeout=2, pps_host=None):
    """
    Delete all bookings in a group recurrence
    :param cfg:
    :param plannerId:
    :param timeout:
    :param pps_host:
    :return:
    """
    protocol = cfg['protocol']
    pps_port = cfg['pps']['port']

    if pps_host is None:
        pps_host = cfg['pps']['host']

    header = get_header(plannerId)
    if header is None:
        print "Unable to get the headers"
        return False, None

    payload = {}
    payload["groupId"] = groupId
    payload["groupType"] = groupType

    url = protocol + "://" + pps_host + ":" + str(pps_port) + "/pps/v3/utils/deleteAllBookingsInGroup"
    print "Delete All bookings in group with url :", url
    r = sendURL("post", url, server_timeout=timeout, header=header, payload_content=payload)

    if r.status_code == 200:
        return True, None
    else:
        return False, r


def delete_recurrencebyGroupId(cfg, plannerId, itemId, groupId, groupType, timeout=2, pps_host=None):
    """
    Delete the particular booking based on GroupID
    :param cfg:
    :param plannerId:
    :param timeout:
    :param pps_host:
    :return:
    """
    protocol = cfg['protocol']
    pps_port = cfg['pps']['port']

    if pps_host is None:
        pps_host = cfg['pps']['host']

    header = get_header(plannerId)
    if header is None:
        print "Unable to get the headers"
        return False, None

    payload = {}
    payload["groupId"] = groupId
    payload["groupType"] = groupType

    url = protocol + "://" + pps_host + ":" + str(pps_port) + "/pps/v3/utils/deleteRecurrenceByGroupId"
    print "Delete Recurrence bookings in group with url :", url
    r = sendURL("post", url, server_timeout=timeout, header=header, payload_content=payload)

    if r.status_code == 200:
        return True, None
    else:
        return False, r


def verify_failed(cfg, plannerId, contentRef, timeout=2, pps_host=None):
    """
    Verify that the contentRef is in failed catalog for the planner
    :param cfg:
    :param plannerId:
    :param contentRef2:
    :param timeout:
    :param pps_host:
    :return:
    """
    resp = get_failures(cfg, plannerId, timeout, pps_host)
    if resp:
        out = json.loads(resp.content)
        if "failures" in out:
            for cont in out["failures"]:
                if cont['contentRef'] == contentRef:
                    return True, cont
        else:
            print "failures block is not present in the response"
            return False, None
    else:
        print "Unable to verify the content is in Failed state"
        return False, None


def find_booking_conflicts(cfg, plannerId, channel, startGuardTime = "PT0S", endGuardTime = "PT0S", eventDuration = 0,
                           eventStartTime = 0, pps_host=None, timeout=2):
    """
    This returns all of the bookings that currently conflict with the event referenced by the supplied query parameters.
    Guard times will be included in the conflict detection according to system policy.
    :param cfg:
    :param plannerId:
    :param channel:
    :param startGuardTime:
    :param endGuardTime:
    :param eventDuration:
    :param eventStartTime:
    :return:
    """

    protocol = cfg['protocol']
    pps_port = cfg['pps']['port']

    if pps_host is None:
        pps_host = cfg['pps']['host']

    header = get_header(plannerId)
    if header is None:
        print "Unable to get the headers"
        return False, None

    if not eventDuration.isdigit():
        eventDuration = str(epoch2iso(eventDuration))

    if not eventStartTime.isdigit():
        eventStartTime = str(epoch2iso(eventStartTime))

    if startGuardTime != "PT0S":
        startGuardTime = str(sec2interval(startGuardTime*60))

    if endGuardTime != "PT0S":
        endGuardTime = str(sec2interval(endGuardTime*60))


    url = protocol + "://" + pps_host + ":" + str(pps_port) + "/pps/v3/utils/findBookingConflicts?channel=%s&event" \
                                                              "Duration=%s&eventStartTime=%s&startGuardTime=%s&end" \
                                                              "GuardTime=%s" % (channel, eventDuration, eventStartTime,
                                                                                startGuardTime, endGuardTime)
    print "Find booking conflicts with url :", url
    r = sendURL("post", url, server_timeout=timeout, header=header)

    if r.status_code == 200:
        return True, None
    else:
        return False, r


# Deprecated
def get_contentRef_from_groupId(cfg, plannerId, groupid, timeout=2, seriesResolution_host=None):
    """
    Get the Content Ref from the Group Id
    :param cfg:
    :param plannerId:
    :param groupid:
    :param timeout:
    :param planner_host:
    :return:
    """
    try:
        protocol = cfg['protocol']
        planner_port = cfg['seriesResolution']['port']

        if seriesResolution_host is None:
            planner_host = cfg['seriesResolution']['host']

        header = get_header(plannerId)
        if header is None:
            print "Unable to get the headers"
            return False, None

        url = protocol + "://" + planner_host + ":" + str(planner_port) + "/planner/seriesResolution/groupContents" \
                                                                          "AndInstances?groupId=%s" % groupid

        r = sendURL("get", url, server_timeout=timeout, header=header)

        if r is not None:
            if r.status_code != 201:
                print "PPS V3 Unable to Content Ref via url %s" % url
                print r.status_code
                print r.headers
                return False, r
            else:
                print "PPS V3. Got the ContentRef from the GroupId"
                return True, r
        else:
            return False, None

    except Exception as e:
        print "Error in get ContentRef from GroupId :\n", str(e)

# Deprecated
def get_groupId_from_contentRef(cfg, plannerId, contentRef, timeout=2, seriesResolution_host=None):
    try:
        protocol = cfg['protocol']
        planner_port = cfg['seriesResolution']['port']

        if seriesResolution_host is None:
            planner_host = cfg['seriesResolution']['host']

        header = get_header(plannerId)
        if header is None:
            print "Unable to get the headers"
            return False, None

        url = protocol + "://" + planner_host + ":" + str(planner_port) + "/planner/seriesResolution/contentGroups?" \
                                                                          "contentRef=%s" % contentRef

        r = sendURL("get", url, server_timeout=timeout, header=header)

        if r is not None:
            if r.status_code != 201:
                print "PPS V3 Unable to Group ID via url %s" % url
                print r.status_code
                print r.headers
                return False, r
            else:
                print "PPS V3. Got the Group ID for the Content ref :", contentRef
                return True, r
        else:
            return False, None

    except Exception as e:
        print "Error in get Groupid from ContentRef :\n", str(e)

# Deprecated
def get_contentRef_of_groupId(cfg, plannerId, groupid, timeout=2, seriesResolution_host=None):
    """
    To get the list of contentRefs associated with a groupId
    Return the list of episode contentRefs of the GroupId specified.
    :param cfg:
    :param plannerId:
    :param groupid:
    :param timeout:
    :param seriesResolution_host:
    :return:
    """
    res, resp = get_contentRef_from_groupId(cfg, plannerId, groupid, timeout=timeout,
                                            seriesResolution_host=seriesResolution_host)
    if res:
        contents = json.loads(resp.content)
        all_content_ids = []
        if contents:
            if contents["contentGroupId"] == groupid:
                for cont in contents["contents"]:
                    all_content_ids.append(cont['contentRef'])
            else:
                print "Group id in the Response doesn't match with the one supplied."
                print "Group id in Response :", contents["contentGroupId"]
                return False, resp

            if all_content_ids:
                return True, all_content_ids
            else:
                print "There is no episode associated with the GroupId"
                return False, resp
        else:
            print "Response from seriesResolution is empty"
            return False, None

# Deprecated
def get_groupId_of_contentRef(cfg, plannerId, contentRef, timeout=2, seriesResolution_host=None):
    """
    To get the list of GroupId associated with a contentRef.
    :param cfg:
    :param plannerId:
    :param groupid:
    :param timeout:
    :param seriesResolution_host:
    :return:
    """
    ret, resp = get_groupId_from_contentRef(cfg, plannerId, contentRef, timeout=timeout,
                                            seriesResolution_host=seriesResolution_host)
    if ret:
        contents = json.loads(resp.content)
        all_group_ids = []
        if contents:
            if contents["contentRef"] == contentRef:
                for cont in contents["groups"]:
                    all_group_ids.append(cont['groupId'])
            else:
                print "ContentRef in the Response doesn't match with the one supplied."
                print "ContentRef in Response :", contents["contentRef"]
                return False, resp

            if all_group_ids:
                return True, all_group_ids
            else:
                print "There is no group Id associated with the contentRef"
                return False, resp
        else:
            print "Response from seriesResolution is empty"
            return False, None


def get_recording(cfg, plannerId, itemid, timeout=2, pps_host=None):
    """
    Get the All the Recording of a Planner with the item id
    :param cfg: config parameter
    :param plannerId: planner id
    :param itemid: item id of the recording to get
    :param timeout: timeout value
    :param pps_host: pps host <optional>
    :return: (True, Response) if success else (False, None)
    """

    try:
        protocol = cfg['protocol']
        pps_port = cfg['pps']['port']

        if pps_host is None:
            pps_host = cfg['pps']['host']

        header = get_header(plannerId)
        if header is None:
            print "Unable to get the headers"
            return False, None
        rec_details = None
        res, resp = get_recordings(cfg, plannerId)
        if res and resp:
            r = json.loads(resp.content)
            for i in r['recordings']:
                if i['itemId'] == itemid:
                    rec_details = i

        if rec_details:
            return True, rec_details
        else:
            return False, None

        '''
        url = protocol + "://" + pps_host + ":" + str(pps_port) + "/pps/v3/core/recordings/getRecording?itemId=%s" %\
                                                                  itemid
        print "Get Recording via URL : ", url

        r = sendURL("get", url, server_timeout=timeout, header=header)

        if r is not None:
            if r.status_code != 200:
                print "PPS V3 Unable to get Recording"
                print r.status_code
                print r.headers
                return False, r
            else:
                print "PPS V3 got the Recording"
                return True, r
        else:
            return False, None
        '''

    except Exception as e:
        print "Error in PPS V3 get Recording:\n", str(e)
        return False, None


def get_recordings(cfg, plannerId, sort = "START-TIME", limit=999, timeout=2, pps_host=None):
    """
    Get all the Recordings of a Planner Id. Can be sorted in either ways - (START-TIME, START-TIME-REVERSE)
    limit can be set greater than 1, lesser than 1000.
    :param cfg: config parameter
    :param plannerId: planner id
    :param timeout: timeout value
    :param pps_host: pps host <optional>
    :return: (True, response) if success else (False, None)
    """
    try:
        protocol = cfg['protocol']
        pps_port = cfg['pps']['port']

        if pps_host is None:
            pps_host = cfg['pps']['host']

        header = get_header(plannerId)
        if header is None:
            print "Unable to get the headers"
            return False, None

        url = protocol + "://" + pps_host + ":" + str(pps_port) + "/pps/v3/core/recordings/getRecordings?sort=%s&" \
                                                                  "limit=%d" % (sort, limit)
        print "Get Recordings of planner via URL:",url

        r = sendURL("get", url, server_timeout=timeout, header=header)

        if r is not None:
            if r.status_code != 200:
                print "PPS V3 Unable to get the Recordings via url %s" %url
                print r.status_code
                print r.headers
                return False, r
            else:
                print "PPS V3. Got the recording of the planner %s"%plannerId
                return True, r
        else:
            return False, None

    except Exception as e:
        print "Error in PPS V3 get Recording :\n", str(e)
        return False, None


def get_count(cfg, plannerId, pps_host=None, recurrence=False, bookings=False, failure=False, timeout=2):
    """
    To get count for recordings, bookings for both indie, & recurrences.
    By default, it returns count of recordings present in a planner.
    :param cfg:
    :param plannerId:
    :recurrence:
    :bookings:
    :recordings:
    :return:
    """
    try:
        protocol = cfg['protocol']
        pps_port = cfg['pps']['port']

        if pps_host is None:
            pps_host = cfg['pps']['host']

        header = get_header(plannerId)
        if header is None:
            print "Unable to get the headers"
            return False, None

        if recurrence:
            url = protocol + "://" + pps_host + ":" + str(pps_port) + "/pps/v3/core/recurrences/countRecurrences"

            print "Get recurrence count via URL : ", url

        elif bookings:
            url = protocol + "://" + pps_host + ":" + str(pps_port) + "/pps/v3/core/bookings/countBookings"
            print "Get Booking count via URL : ", url

        elif failure:
            url = protocol + "://" + pps_host + ":" + str(pps_port) + "/pps/v3/core/failures/countFailures"
            print "Get Failures count of planner via URL:", url

        else:
            url = protocol + "://" + pps_host + ":" + str(pps_port) + "/pps/v3/core/recordings/countRecordings"
            print "Get Recordings count of planner via URL:", url

        r = sendURL("get", url, server_timeout=timeout, header=header)

        if r is not None:
            if r.status_code != 200:
                print "PPS V3 Unable to get the count via url %s" % url
                print r.status_code
                print r.headers
                return False, r
            else:
                r = json.loads(r.content)
                r = r['count']
                print "PPS V3. Got the count of the planner %s" % plannerId
                return True, r
        else:
            return False, None

    except Exception as e:
        print "Error in PPS V3 get count :\n", str(e)
        return False, None


# Deprecated
def get_metadata_of_recording(cfg, plannerId, timeout=2, contendId=None, location_url = None, pps_host=None):
    """
    Get the metadate of the recording from the location url in the response of booking
    :param cfg:
    :param plannerId:
    :param contendId:
    :param location_url:
    :param timeout:
    :param pps_host:
    :return:
    """
    try:
        if location_url is None:
            protocol = cfg['protocol']
            pps_port = cfg['pps']['port']

            if pps_host is None:
                pps_host = cfg['pps']['host']

            url = protocol + "://" + pps_host + ":" + str(pps_port) + "/pps/households/"+str(plannerId)+"/catalog/"+\
                  str(contendId)

        else:
            url = location_url

        r = sendURL("get", url, server_timeout=timeout)

        if r is not None:
            if r.status_code != 201:
                print "PPS V3 Unable to get metadata of Recordings via url %s" %url
                print r.status_code
                print r.headers
                return False, r
            else:
                print "PPS V3. Got the Metadata of Recording : %s" %contendId
                return True, r
        else:
            return False, None

    except Exception as e:
        print "Error in PPS V3 get Metadata of Recording :\n", str(e)
        return False, None


def delete_recording(cfg, plannerId, itemids, timeout=2, pps_host=None):
    """
    Delete the recording based on the Itemid supplied
    :param cfg: config parameter
    :param plannerId: planner id
    :param itemid: item id of recording to delete
    :param timeout: timeout value
    :param pps_host: pps host(optional)
    :return: True if all the recordings are deleted else False
    """

    try:
        protocol = cfg['protocol']
        pps_port = cfg['pps']['port']

        if pps_host is None:
            pps_host = cfg['pps']['host']

        headers = get_booking_header(plannerId)
        if headers is None:
            print "Unable to get the booking headers"
            return False

        if not isinstance(itemids, list):
            itemids = [itemids]

        delete_fail = []
        delete_pass = []

        for itemid in itemids:
            payload = """{
                        itemId:%s
                         }""" % itemid

            url = protocol + "://" + pps_host + ":" + str(pps_port) + "/pps/v3/core/recordings/deleteRecording"
            print "Delete the Recording with url :", url

            r = sendURL("post", url, server_timeout=timeout, header=headers, payload_content=payload)

            if r is not None:
                if r.status_code != 200:
                    print "Unable to Delete the Recording %s"%itemid
                    print r.status_code
                    print r.headers
                    delete_fail.append(itemid)
                else:
                    print "PPS V3 - Delete Recording successful"
                    delete_pass.append(itemid)
            else:
                delete_fail.append(itemid)

        if not delete_fail and len(delete_pass) == len(itemids):
            print "All recordings got Deleted successfully"
            return True
        else:
            print "Following Recordings were not deleted"
            print delete_fail
            return False

    except Exception as e:
        print "Error in PPS V3 Delete Recording:\n", str(e)
        return False


def verify_booked(cfg, plannerId, itemids, timeout=2, pps_host=None):
    """
    Verify the item is in booking state.
    The content is counted irrespective of recordingInProgress state
    :param cfg: config parameter
    :param plannerId: planner id
    :param itemids: itemids
    :param timeout: timeout value
    :param pps_host: pps host <optional>
    :return:
    """

    if not isinstance(itemids, list):
        itemids = [itemids]

    book_pass =[]
    book_fail=[]
    for itemid in itemids:
        result, response = get_booking(cfg, plannerId, itemid, timeout, pps_host)
        if result:
            r = json.loads(response.content)
            if "bookings" in r:
                contents = r["bookings"]
                for cont in contents:
                    if cont["recordingInProgress"] == "false" or cont["recordingInProgress"] == "true":
                        book_pass.append(itemid)
                    else:
                        book_fail.append(itemid)
            else:
                print "Bookings response doesn't have the bookings block for itemid %s" %itemid
                book_fail.append(itemid)
        else:
            book_fail.append(itemid)

    if not book_fail and len(book_pass) == len(itemids):
        print "All the itemIds are in booking state"
        return True
    else:
        print "Some itemIds are not in booking state: ", book_fail
        return False


def verify_recording(cfg, plannerId, itemids, timeout=2, pps_host=None):
    """
        Verify the content is in recording state.
        :param cfg: config parameter
        :param plannerId: planner id
        :param itemids: item id to verify
        :param timeout: timeout value
        :param pps_host: pps host <optional>
        :return: True if success else False
        """

    if not isinstance(itemids, list):
        itemids = [itemids]

    recording_pass = []
    recording_fail = []
    for itemid in itemids:
        result, response = get_recording(cfg, plannerId, itemid, timeout, pps_host)

        if result:
            r = json.loads(response.content)
            if "recordings" in r:
                contents = r["recordings"]
                for cont in contents:
                    if cont["isRecordingComplete"] == "false":
                        recording_pass.append(itemid)
                    else:
                        recording_fail.append(itemid)
            else:
                print "Response doesn't have the recordings block for itemid %s" %itemid
                recording_fail.append(itemid)
        else:
            recording_fail.append(itemid)

    if not recording_fail and len(recording_pass) == len(itemids):
        print "All the itemids are in Recording state"
        return True
    else:
        print "Some itemids are not in recording state: ", recording_fail
        return False


def verify_recorded(cfg, plannerId, itemids, timeout=2, pps_host=None):
    """
    Verify the content is in recording state.
    :param cfg: config paratmeter
    :param plannerId: planner id
    :param itemids: item id to verify
    :param timeout: timeout value
    :param pps_host: pps host <optional>
    :return: True if success else False
    """

    if not isinstance(itemids, list):
        itemids = [itemids]

    recorded_pass = []
    recorded_fail = []
    for itemid in itemids:
        result, response = get_recording(cfg, plannerId, itemid, timeout, pps_host)

        if result:
            r = json.loads(response.content)
            if "recordings" in r:
                contents = r["recordings"]
                for cont in contents:
                    if cont["isRecordingComplete"] == "true":
                        recorded_pass.append(itemid)
                    else:
                        recorded_fail.append(itemid)
            else:
                print "Response doesn't have the recordings block for itemid %s" %itemid
                recorded_fail.append(itemid)
        else:
            recorded_fail.append(itemid)

    if not recorded_fail and len(recorded_pass) == len(itemids):
        print "All the itemids are in Recorded state"
        return True
    else:
        print "Some itemdids are not in recorded state : ", recorded_fail
        return False


'''def interval2sec(duration):
    try:
        try:
            d = datetime.datetime.strptime(duration, 'PT%HH%MM%SS')
            total = (d.hour * 3600) + (d.minute * 60) + d.second
            return total
        except:
            pass

        try:
            d = datetime.datetime.strptime(duration, 'PT%MM%SS')
            total = (d.hour * 3600) + (d.minute * 60) + d.second
            return total
        except:
            pass

        try:
            d = datetime.datetime.strptime(duration, 'PT%SS')
            total = (d.hour * 3600) + (d.minute * 60) + d.second
            return total
        except:
            pass

        try:
            d = datetime.datetime.strptime(duration, 'PT%MM')
            total = (d.hour * 3600) + (d.minute * 60) + d.second
            return total
        except:
            pass

        try:
            d = datetime.datetime.strptime(duration, 'PT%HH')
            total = (d.hour * 3600) + (d.minute * 60) + d.second
            return total
        except:
            pass

    except:
        print "Unable to convert the PT time to seconds"
        return False'''

def interval2sec(duration):

    try:
        # reg = r'(\d{2}[A-Z])'
        reg = r'([0-9]+[A-Z])'

        mtch = re.findall(reg, duration)
        hh = mm = ss = dd = 0
        for mt in mtch:
            # print mt
            if mt.endswith("H"):
                hh = 3600 * int(mt.replace("H", ""))
            if mt.endswith("M"):
                mm = 60 * int(mt.replace("M", ""))

            if mt.endswith("S"):
                ss = int(mt.replace("S", ""))

            if mt.endswith("D"):
                dd = int(mt.replace("D", ""))
                return dd

        total_sec = hh + mm + ss

        #print "Total sec :", total_sec
        return total_sec
    except Exception as e:
        print "Error in interval2sec.\n", str(e)
        return False


def sec2interval(seconds):
    '''if type(seconds) is int:
        return time.strftime('PT%HH%MM%SS', time.gmtime(seconds))
    else:
        return False'''

    hh = seconds / 3600
    #print hh
    #seconds = seconds % 60
    #print ">>", seconds
    mm = (seconds % 3600) / 60
    #print mm
    seconds = seconds % 60
    #print seconds

    return "PT%02dH%02dM%02dS"%(hh,mm,seconds)



def get_contentref_details(contents):
    """

    :param contents:
    :return: [('program-1497248599', 1497248779, 1497249079, 300, 'program-149724~485992'),
              ('program-1497248600', 1497249079, 1497249379, 300, 'program-149724~486002')]
    """
    final_list=[]
    for cont in contents:
        temp_list = []
        contref = cont[0]
        strtTime = iso2epoch(cont[1])
        duration = interval2sec(cont[2])
        endTime = strtTime + duration

        temp_list.append(contref)
        temp_list.append(strtTime)
        temp_list.append(endTime)
        temp_list.append(duration)

        if len(cont) > 3:
            temp_list.append(cont[3])

        final_list.append(tuple(temp_list))

    return final_list


def get_contentref_details_series(series):
    """

    :param series:
    :return: [('program-1497248601', 1497248601, 1497248781, 180, 'test-149724~486012', 1, 'SER143'),
              ('program-1497248602', 1497248781, 1497248961, 180, 'test-149724~486022', 2, 'SER143'),
              ('program-1497248603', 1497248961, 1497249141, 180, 'test-149724~486032', 3, 'SER143')]
    """
    final_list = []

    for ser, episodes in series.items():
        for ep in episodes:
            temp_list = []
            contref = ep[0]
            strtTime = iso2epoch(ep[1])
            duration = interval2sec(ep[2])
            endTime = strtTime + duration
            episode_num = ep[3]

            temp_list.append(contref)
            temp_list.append(strtTime)
            temp_list.append(endTime)
            temp_list.append(duration)
            if len(ep) > 3:
                temp_list.append(ep[4])
            temp_list.append(episode_num)
            temp_list.append(ser)

            final_list.append(tuple(temp_list))

    return final_list

def stop_recording_inprogress(cfg, plannerid, itemid, timeout=2, pps_host=None):
    """
    Stop a recoding which is in-progress
    :param cfg:
    :param plannerid:
    :return:
    """

    try:
        protocol = cfg['protocol']
        pps_port = cfg['pps']['port']

        if pps_host is None:
            pps_host = cfg['pps']['host']

        headers = get_booking_header(plannerid)
        if headers is None:
            print "Unable to get the booking headers"
            return False

        if not isinstance(itemid, list):
            itemids = [itemid]

        stop_fail = []
        stop_pass = []

        for itemid in itemids:
            payload = """{
                                itemId:%s
                                 }""" % itemid

            url = protocol + "://" + pps_host + ":" + str(pps_port) + "/pps/v3/core/recordings/stopRecordingInProgress"
            print "Stop the Recording In-progress with url :", url

            r = sendURL("post", url, server_timeout=timeout, header=headers, payload_content=payload)

            if r is not None:
                if r.status_code != 200:
                    print "Unable to Stop the Recording %s" % itemid
                    print r.status_code
                    print r.headers
                    stop_fail.append(itemid)
                else:
                    print "PPS V3 - Stop Recording successful"
                    stop_pass.append(itemid)
            else:
                stop_fail.append(itemid)

        if not stop_fail and len(stop_pass) == len(itemids):
            print "All recordings got Stopped successfully"
            return True
        else:
            print "Following Recordings were not Stopped"
            print stop_fail
            return False

    except Exception as e:
        print "Error in PPS V3 Stop Recording :\n", str(e)
        return False


def diskspace_details(cfg, plannerId, pps_host=None, timeout=2):
    """
    To find Free, total, & used Diskspace for a planner.
    :param cfg:
    :param plannerId:
    :param timeout:
    :return:
    """
    try:
        protocol = cfg['protocol']
        pps_port = cfg['pps']['port']

        if pps_host is None:
            pps_host = cfg['pps']['host']

        headers = get_booking_header(plannerId)
        if headers is None:
            print "Unable to get the booking headers"
            return False

        url = protocol + "://" + pps_host + ":" + str(pps_port) + "/pps/v3/utils/diskspace"
        print "Fetch the Disk space details with url :", url

        r = sendURL("get", url, server_timeout=timeout, header=headers)

        if r is not None:
            if r.status_code != 200:
                print "Unable to fetch disk space details for the planner %s" % plannerId
                print r.status_code
                print r.headers
                return False, r
            else:
                print "PPS V3 - Fetch Disk space is successful"
                return True, r

    except Exception as e:
        print "Error in PPS V3 fetch diskspace:\n", str(e)
        return False


def debug_print(cfg, planner):
    print "#"*10, " DEBUG STARTED ON PLANNER ", planner, " ", "#"*10

    print "#" * 10, " DEBUG ENDED ON PLANNER ", planner, " ", "#" * 10

if __name__ =="__main__":
    '''print get_booking_header("keya2")
    plannerId = "keya1"

    cfg={}
    cfg['pps'] = {'host': "10.78.221.239",'port': "6060"}
    cfg['seriesResolution'] = {'host':"10.78.221.239",'port': "6060"}
    cfg['protocol'] = "http"

    payload = """{
                            "eventChannel": "123",
                            "eventStartTime": "2017-01-19T13:55:00Z",
                            "eventDurationInSeconds": "3000",
                            "metadataContentRef":"program-404387-514850",
                            "recurrence":"series"}"""

    ret, resp = create_booking(cfg, plannerId, payload, timeout=2, printflg=False, pps_host="10.78.221.239")
    print "#### Response ####\n"
    print resp.headers
    print "\n##################"

    ev = [('program-1497248599', '2017-06-12T06:26:19Z', 'PT00H05M00S', 'program-149724~485992'),
          ('program-1497248600', '2017-06-12T06:31:19Z', 'PT00H05M00S', 'program-149724~486002')]
    sr = sr = {'SER143': [('program-1497248601', '2017-06-12T06:23:21Z', 'PT00H03M00S', 1, 'test-149724~486012'),
                          ('program-1497248602', '2017-06-12T06:26:21Z', 'PT00H03M00S', 2, 'test-149724~486022'),
                          ('program-1497248603', '2017-06-12T06:29:21Z', 'PT00H03M00S', 3, 'test-149724~486032')]}
    print get_contentref_details(ev)
    print get_contentref_details_series(sr)'''



    print interval2sec("PT00H15M25S")
    print sec2interval(925)
